Analytical Report: Optimization of City Transportation Network
1. Summary of Input Data and Algorithm Results
   This project implements Prim’s and Kruskal’s algorithms to compute Minimum Spanning Trees (MSTs) for a city transportation network, as specified in the assignment. The implementation is written in Java, with classes organized in the org.example package. Input data is generated and stored in assign_3_input.json, and results are output in assign_3_output.json. The program processes three graphs of varying sizes and densities, designed to test correctness, performance, and scalability. Automated tests in MSTTest.java verify the correctness and performance metrics of both algorithms. Below is a detailed summary of the input data and results based on the provided assign_3_output.json.
   Input Data
   The input, generated by Main.java, consists of three undirected weighted graphs with string-based node labels (e.g., "A", "B"). The graphs are stored in assign_3_input.json in the format {"graphs": [{"id": 1, "nodes": [...], "edges": [...]}]}, where edges specify from, to, and weight. The graphs are:

Graph 1 (Small):
Vertices: 5 (A, B, C, D, E)
Edges: 6
Density: Dense (~48% edge density, calculated as 6 / (5 * 4 / 2)).
Description: A small graph designed for correctness testing and debugging, representing a compact urban network with high connectivity.


Graph 2 (Medium):
Vertices: 10 (A, B, C, D, E, F, G, H, I, J)
Edges: 20
Density: Moderately dense (~44% edge density, 20 / (10 * 9 / 2)).
Description: A medium-sized graph to evaluate performance on moderately complex networks, such as a city with multiple districts.


Graph 3 (Large):
Vertices: 20 (A, B, C, ..., S, T)
Edges: 60
Density: Sparse (~15% edge density, 60 / (20 * 19 / 2)).
Description: A large graph to test scalability, representing a regional network with sparse connections.



Algorithm Results
Both Prim’s and Kruskal’s algorithms compute MSTs, recording the list of edges, total cost, operation count, and execution time in milliseconds. Results are stored in assign_3_output.json in the format {"results": [{"graph_id": 1, "input_stats": {...}, "prim": {...}, "kruskal": {...}}]}, with node labels used for edges. The following details are extracted from the provided JSON output.

Graph 1 (Small, 5 vertices, 6 edges):

Prim’s Algorithm:
MST Edges: A–B (2.0), B–C (1.0), B–D (4.0), D–E (2.0)
Total Cost: 9.0
Operations Count: 12 (priority queue operations and edge comparisons)
Execution Time: 1 ms
Notes: The MST connects all 5 vertices with 4 edges, minimizing total weight.


Kruskal’s Algorithm:
MST Edges: B–C (1.0), A–B (2.0), D–E (2.0), B–D (4.0)
Total Cost: 9.0
Operations Count: 6 (union-find operations and edge sorting)
Execution Time: 1 ms
Notes: The MST is equivalent to Prim’s (same cost, different edge order).




Graph 2 (Medium, 10 vertices, 20 edges):

Prim’s Algorithm:
MST Edges: A–G (1.40), G–E (0.28), E–H (4.70), H–J (1.02), H–I (3.53), J–D (4.12), D–B (4.79), D–C (4.90), G–F (6.79)
Total Cost: 31.53
Operations Count: 30 (priority queue operations and edge comparisons)
Execution Time: 0 ms
Notes: The MST includes 9 edges, connecting all vertices efficiently.


Kruskal’s Algorithm:
MST Edges: E–G (0.28), H–J (1.02), A–G (1.40), H–I (3.53), D–J (4.12), E–H (4.70), B–D (4.79), C–D (4.90), F–G (6.79)
Total Cost: 31.53
Operations Count: 20 (union-find operations and edge sorting)
Execution Time: 0 ms
Notes: Same total cost as Prim’s, with a different edge selection due to non-unique MSTs.




Graph 3 (Large, 20 vertices, 60 edges):

Prim’s Algorithm:
MST Edges: A–B (0.76), B–D (1.00), A–T (1.75), T–N (1.59), B–S (2.61), S–I (1.07), A–J (2.77), I–H (3.46), N–K (3.93), K–O (0.99), O–Q (1.37), K–F (3.15), J–L (4.62), F–P (6.00), P–E (2.07), E–R (3.48), R–C (3.68), J–G (8.02), F–M (9.69)
Total Cost: 62.00
Operations Count: 74 (priority queue operations and edge comparisons)
Execution Time: 0 ms
Notes: The MST spans 19 edges, covering all 20 vertices.


Kruskal’s Algorithm:
MST Edges: A–B (0.76), K–O (0.99), B–D (1.00), I–S (1.07), O–Q (1.37), N–T (1.59), A–T (1.75), E–P (2.07), B–S (2.61), A–J (2.77), F–K (3.15), H–I (3.46), E–R (3.48), C–R (3.68), K–N (3.93), J–L (4.62), F–P (6.00), G–J (8.02), F–M (9.69)
Total Cost: 62.00
Operations Count: 60 (union-find operations and edge sorting)
Execution Time: 0 ms
Notes: Identical cost to Prim’s, with different edge ordering.





Implementation Details

Project Structure:
Source Files: Located in src/main/java/org/example/:
Edge.java: Defines an edge with source, destination, and weight (integer vertices, double weight).
Graph.java: Represents the graph with a vertex count and edge list, supporting adjacency list operations.
Prim.java: Implements Prim’s algorithm using a priority queue to select minimum-weight edges.
Kruskal.java: Implements Kruskal’s algorithm with a union-find data structure to avoid cycles.
Main.java: Handles input parsing, graph generation, algorithm execution, and output writing.


Test Files: Located in src/test/java/org/example/:
MSTTest.java: JUnit tests for correctness and performance.


Other Files:
pom.xml: Maven configuration for dependencies (json-simple, junit).
assign_3_input.json: Generated input with three graphs.
assign_3_output.json: Output with MST results.




Input Processing:
Main.java maps string node labels (e.g., "A") to integer indices for internal processing, then maps back to strings for output.
Supports the JSON format: {"graphs": [{"id": 1, "nodes": ["A", "B", ...], "edges": [{"from": "A", "to": "B", "weight": 2.0}, ...]}]}


Output:
Results are written to assign_3_output.json in the format: {"results": [{"graph_id": 1, "input_stats": {"vertices": 5, "edges": 6}, "prim": {...}, "kruskal": {...}}]}
Includes MST edges, total cost, operation count, and execution time for both algorithms.


Testing:
MSTTest.java includes:
Correctness Tests:
Verifies identical total costs (within 0.0001 tolerance).
Ensures MSTs have V-1 edges.
Checks for no cycles using union-find.
Confirms connectivity using DFS.
Handles disconnected graphs by producing partial MSTs.


Performance Tests:
Ensures non-negative execution times and operation counts.
Verifies reproducibility for the same dataset.




Tests are executed via Maven (mvn test).



2. Comparison of Prim’s and Kruskal’s Algorithms
   Theoretical Comparison

Prim’s Algorithm:

Time Complexity: O(E log V) with a binary heap priority queue, where E is the number of edges and V is the number of vertices. With a Fibonacci heap, it can be O(E + V log V), but this implementation uses a binary heap for simplicity.
Space Complexity: O(V) for the priority queue, key array, and visited set.
Algorithm Mechanics: Starts from a single vertex, iteratively adding the minimum-weight edge connecting a visited vertex to an unvisited one. Uses a priority queue to select the next edge efficiently.
Suitability: Best for dense graphs (E ≈ V²), as it processes each vertex’s adjacent edges, minimizing redundant operations in high-connectivity scenarios.
Implementation Complexity: Moderate, requiring a priority queue and careful handling of edge updates.


Kruskal’s Algorithm:

Time Complexity: O(E log E) for sorting edges, plus O(E α(V)) for union-find operations, where α(V) is the inverse Ackermann function (nearly constant). The dominant factor is edge sorting.
Space Complexity: O(E + V) for storing the sorted edge list and union-find data structure.
Algorithm Mechanics: Sorts all edges by weight, then adds edges to the MST if they connect different components, using union-find to detect cycles.
Suitability: Ideal for sparse graphs, as it processes edges directly and benefits from fewer edges to sort and check.
Implementation Complexity: Simpler than Prim’s, as union-find is straightforward and edge sorting leverages standard libraries.



Practical Comparison
The results from assign_3_output.json provide insights into the practical performance of both algorithms across the three graphs:

Graph 1 (Small, 5 vertices, 6 edges, 48% density):

Prim’s: 12 operations (priority queue insertions/removals and edge comparisons), 1 ms.
Kruskal’s: 6 operations (edge sorting and union-find operations), 1 ms.
Analysis: Kruskal’s requires fewer operations due to the small edge set and efficient union-find. The dense nature of the graph minimizes the difference, but Prim’s priority queue overhead is noticeable. Execution times are identical due to coarse millisecond resolution.


Graph 2 (Medium, 10 vertices, 20 edges, 44% density):

Prim’s: 30 operations, 0 ms.
Kruskal’s: 20 operations, 0 ms.
Analysis: Kruskal’s benefits from moderate density, as sorting 20 edges is efficient, and union-find operations are minimal. Prim’s processes more edges per vertex, increasing operations. Execution times are too small to differentiate.


Graph 3 (Large, 20 vertices, 60 edges, 15% density):

Prim’s: 74 operations, 0 ms.
Kruskal’s: 60 operations, 0 ms.
Analysis: Kruskal’s outperforms in this sparse graph, as sorting 60 edges is less costly than Prim’s priority queue operations across 20 vertices. The operation count gap widens due to sparsity.



Key Observations

Operation Counts: Kruskal’s consistently uses fewer operations (6 vs. 12, 20 vs. 30, 60 vs. 74), reflecting its efficiency in sparse to moderately dense graphs. Prim’s priority queue operations scale with vertex degree, which is higher in denser graphs.
Execution Time: Both algorithms show near-zero times (0–1 ms) due to small graph sizes and modern hardware. Millisecond resolution is insufficient to capture differences; nanosecond timing would provide more insight.
Correctness: Both algorithms produce identical total costs (9.0, 31.53, 62.00), as verified by MSTTest.java. Edge sets may differ due to non-unique MSTs, but the total weight is consistent.
Scalability: Kruskal’s advantage grows with larger, sparser graphs, while Prim’s performs better in denser scenarios.

3. Conclusions
   Algorithm Suitability

Prim’s Algorithm:

Dense Graphs: Efficient when E approaches V², as it processes vertices and their adjacent edges, reducing the need for global edge sorting. Suitable for Graph 1 and similar urban networks with high connectivity.
Memory Efficiency: Requires O(V) space, making it ideal for systems with limited memory.
Implementation: More complex due to priority queue management but benefits from direct adjacency list access in Graph.java.
Use Case: Best for small to medium dense networks, such as city transportation grids where most locations are interconnected.


Kruskal’s Algorithm:

Sparse Graphs: Excels when E is much smaller than V², as seen in Graph 3 (15% density). Sorting edges and union-find operations scale well with fewer edges.
Parallelization: Edge sorting and union-find can be parallelized, offering potential for distributed systems.
Implementation: Simpler, as union-find is straightforward and leverages Java’s Collections.sort.
Use Case: Ideal for large, sparse networks, such as regional transportation systems with fewer connections.



Conditions Affecting Performance

Graph Density:
Dense Graphs (e.g., Graph 1): Prim’s is comparable but slightly less efficient due to priority queue overhead. The small operation count difference (12 vs. 6) suggests either algorithm is viable for small networks.
Sparse Graphs (e.g., Graph 3): Kruskal’s is faster, with fewer operations (60 vs. 74), as it avoids processing unnecessary edges.


Edge Representation:
The adjacency list in Graph.java suits both algorithms. Prim’s benefits from direct access to adjacent edges, while Kruskal’s pre-sorts edges, mitigating representation differences.


Implementation Complexity:
Prim’s requires careful priority queue handling, increasing development time.
Kruskal’s union-find is simpler to implement and debug, especially for sparse graphs.


Disconnected Graphs:
Both algorithms produce partial MSTs for disconnected graphs, covering only connected components. Explicit detection (e.g., a connectivity flag) could enhance robustness.

